% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aio.R
\name{call_aio}
\alias{call_aio}
\alias{wait_aio}
\title{Call the Value of an Asynchronous Aio Operation}
\usage{
call_aio(aio)

wait_aio(aio)
}
\arguments{
\item{aio}{an Aio (object of class 'sendAio', 'recvAio' or 'ncurlAio').}
}
\value{
The passed object (invisibly).
}
\description{
\code{call_aio} retrieves the value of an asynchronous Aio operation, waiting
    for the operation to complete if still in progress.

\code{wait_aio} is identical to \code{call_aio} but allows user interrupts.
}
\details{
For a 'recvAio', the received value may be retrieved at \code{$data}.

    For a 'sendAio', the send result may be retrieved at \code{$result}. This
    will be zero on success, or else an integer error code.

    To access the values directly, use for example on a 'recvAio' \code{x}:
    \code{call_aio(x)$data}.

    For a 'recvAio', if an error occurred in unserialization or conversion of
    the message data to the specified mode, a raw vector will be returned
    instead to allow recovery (accompanied by a warning).

    Once the value has been successfully retrieved, the Aio is deallocated
    and only the value is stored in the Aio object.

    Note this function operates silently and does not error even if 'aio' is
    not an active Aio, always returning invisibly the passed object.
}
\section{Alternatively}{


    Aio values may be accessed directly at \code{$result} for a 'sendAio',
    and \code{$data} for a 'recvAio'. If the Aio operation is yet to complete,
    an 'unresolved' logical NA will be returned. Once complete, the resolved
    value will be returned instead.

    \code{\link{unresolved}} may also be used, which returns TRUE only if an
    Aio or Aio value has yet to resolve and FALSE otherwise. This is suitable
    for use in control flow statements such as \code{while} or \code{if}.
}

\section{Wait}{


    \code{wait_aio} is identical to \code{call_aio} except that it is
    user-interruptible. If interrupted, the aio is stopped upon the next
    garbage collection event, and hence may return an 'errorValue' 20
    'Operation canceled' if it remains unresolved by that time.
}

\examples{
s1 <- socket("pair", listen = "inproc://nanonext")
s2 <- socket("pair", dial = "inproc://nanonext")

res <- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
res
call_aio(res)
res$result

msg <- recv_aio(s2, timeout = 100)
msg
wait_aio(msg)$data

close(s1)
close(s2)

}
