% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aio.R
\name{call_aio}
\alias{call_aio}
\title{Call the Result of an Asynchronous AIO Operation}
\usage{
call_aio(aio)
}
\arguments{
\item{aio}{An Aio (object of class 'sendAio' or 'recvAio').}
}
\value{
The passed Aio object (invisibly).
}
\description{
Retrieve the result of an asynchronous AIO operation, waiting for the AIO
    operation to complete if still in progress.
}
\details{
For a 'recvAio', the received raw vector will be attached in \code{$raw}
    (unless 'keep.raw' was set to FALSE when receiving), and the converted R
    object in \code{$data}.

    For a 'sendAio', the send result will be attached to the Aio in \code{$result}.
    This will be zero on success.

    To access the values directly, use for example on a sendAio 'x':
    \code{call_aio(x)$result}.

    For a 'recvAio', in case of an error in unserialisation or data conversion,
    the received raw vector will be stored in \code{$data} to allow for the
    data to be recovered.

    Once the result has been successfully retrieved, the Aio is deallocated
    and only the result is stored in the Aio object.
}
\section{Alternatively}{


    Aio values may be accessed directly at \code{$result} for a 'sendAio',
    and \code{$raw} or \code{$data} for a 'recvAio'. If the Aio operation is
    yet to complete, an 'unresolved' logical NA will be returned. Once
    completed, the resolved value will be returned instead.

    \code{\link{unresolved}} may also be used, which returns TRUE only if an
    Aio or Aio value has yet to resolve and FALSE otherwise. This is suitable
    for use in control flow statements such as \code{while} or \code{if}.
}

\examples{
s1 <- socket("pair", listen = "inproc://nanonext")
s2 <- socket("pair", dial = "inproc://nanonext")

res <- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
res
call_aio(res)
res$result

msg <- recv_aio(s2, timeout = 100)
msg
call_aio(msg)$data

close(s1)
close(s2)

}
