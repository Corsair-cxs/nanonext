% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aio.R
\name{call_aio}
\alias{call_aio}
\title{Call the Result of an Asynchronous AIO Operation}
\usage{
call_aio(aio)
}
\arguments{
\item{aio}{An Aio (object of class 'sendAio' or 'recvAio').}
}
\value{
The passed Aio object (invisibly).
}
\description{
Retrieve the result of an asynchronous AIO operation, waiting for the AIO
    operation to complete if still in progress.
}
\details{
For a 'recvAio', the received raw vector will be attached in \code{$raw}
    (unless 'keep.raw' was set to FALSE when receiving), and the converted R
    object in \code{$data}.

    For a 'sendAio', the send result will be attached to the Aio in \code{$result}.
    This will be zero on success.

    To access the values directly, use for example on a sendAio 'x':
    \code{call_aio(x)$result}.

    For a 'recvAio', in case of an error in unserialisation or data conversion,
    the received raw vector will be stored in \code{$data} to allow for the
    data to be recovered.

    Once the result has been successfully retrieved, the Aio is deallocated
    and only the result is stored in the Aio object.
}
\section{Non-blocking}{


    To query the value of an Aio without potentially waiting for the Aio
    operation to complete, call the values directly at \code{$result} for a 'sendAio', and
    \code{$raw} or \code{$data} for a 'recvAio'.

    If the Aio operation is yet to complete, the result will be an
    'unresolved value', which is a logical NA. Once complete, the resolved
    value will be returned instead.
}

\examples{
s1 <- socket("pair", listen = "inproc://nanonext")
s2 <- socket("pair", dial = "inproc://nanonext")

res <- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
res
call_aio(res)
res$result

res <- recv_aio(s2, timeout = 100)
res
call_aio(res)$data

close(s1)
close(s2)

}
