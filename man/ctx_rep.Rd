% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{ctx_rep}
\alias{ctx_rep}
\title{Reply over Context (Server for Req/Rep Protocol)}
\usage{
ctx_rep(
  context,
  ...,
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  send_mode = c("serial", "raw"),
  execute,
  timeout
)
}
\arguments{
\item{context}{a Context.}

\item{...}{additional arguments passed to the function specified by 'execute'.}

\item{recv_mode}{[default 'serial'] mode of vector to be received - one of 'serial',
'character', 'complex', 'double', 'integer', 'logical', 'numeric', or 'raw'.
The default 'serial' means a serialised R object, for the other modes,
the raw vector received will be converted into the respective mode.}

\item{send_mode}{[default 'serial'] whether data will be sent serialized or
as a raw vector. Use 'serial' for sending and receiving within R to ensure
perfect reproducibility. Use 'raw' for sending vectors of any type (will be
converted to a raw byte vector for sending) - essential when interfacing
with external applications.}

\item{execute}{a function which takes the received (converted) data as its
first argument. Can be an anonymous function of the form \code{function(x) do(x)}.
Additional arguments can also be passed in through '...'.}

\item{timeout}{in ms. If unspecified, a socket-specific default timeout will
be used. Note this applies to each of the receive and send legs, hence the
total elapsed time could be up to twice this parameter plus the time to
perform 'execute' on the received data.}
}
\value{
Invisible NULL.
}
\description{
Implements an executor/server for the rep node of the req/rep protocol. Awaits
    data, applies an arbitrary specified function, and returns the result
    to the caller/client.
}
\details{
Async recv will block while awaiting a message to arrive and is
    usually the desired result. Set a timeout to allow the function to return
    if no data is forthcoming.

    In case of an error in unserialisation or data conversion, the function
    will return the received raw vector to allow the data to be recovered.
}
\examples{
req <- socket("req", listen = "tcp://127.0.0.1:6546")
rep <- socket("rep", dial = "tcp://127.0.0.1:6546")

ctxq <- context(req)
ctxp <- context(rep)

ctx_send(ctxq, 2022, timeout = 100, echo = FALSE)
ctx_rep(ctxp, execute = function(x) x + 1, send_mode = "raw", timeout = 100)
ctx_recv(ctxq, mode = "double", timeout = 100, keep.raw = FALSE)

ctx_send(ctxq, 100, mode = "raw", timeout = 100, echo = FALSE)
ctx_rep(ctxp, recv_mode = "double", execute = log, base = 10, timeout = 100)
ctx_recv(ctxq, timeout = 100, keep.raw = FALSE)

close(req)
close(rep)

}
