% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{cv}
\alias{cv}
\alias{wait}
\alias{until}
\alias{cv_value}
\alias{cv_adjust}
\alias{cv_reset}
\title{Condition Variables}
\usage{
cv()

wait(cv)

until(cv, msec)

cv_value(cv)

cv_adjust(cv, value)

cv_reset(cv, condition = TRUE, flag = TRUE)
}
\arguments{
\item{cv}{a 'conditionVariable' object.}

\item{msec}{maximum time in milliseconds to wait for the condition variable
to be signalled.}

\item{value}{integer value by which to adjust the condition (counter).}

\item{condition}{[default TRUE] logical value whether to reset the
condition (counter).}

\item{flag}{[default TRUE] logical value whether to reset the flag.}
}
\value{
For \code{cv}: a 'conditionVariable' object.

    For \code{wait} and \code{until}: logical value TRUE, or else FALSE if a
    flag has been set.

    For \code{cv_value}: integer value of the condition variable.

    For \code{cv_adjust} and \code{cv_reset}: invisible NULL.
}
\description{
\code{cv} creates a new condition variable (protected by a mutex internal to
    the object).

\code{wait} waits on a condition being signalled by completion of an
    asynchronous receive.

\code{until} waits until a future time on a condition being signalled by
    completion of an asynchronous receive.

\code{cv_value} inspects the internal value of a condition variable.

\code{cv_adjust} and \code{cv_reset} respectively adjust (by an integer
    value) or reset the internal value of a condition variable.
}
\details{
Pass the 'conditionVariable' to the signalling forms of the
    asynchronous receive functions: \code{\link{recv_aio_signal}} or
    \code{\link{request_signal}}. Alternatively, to be notified of a pipe
    event, pass it to \code{\link{pipe_notify}}.

    Completion of the receive or pipe event, which happens asynchronously and
    independently of the main R thread, will signal the condition variable by
    incrementing it by 1.

    This will cause the R execution thread waiting on the condition variable
    using \code{wait} or \code{until} to wake and continue.

    For arguments 'msec' and 'value', non-integer values will be coerced to
    integer. Non-numeric input will be ignored and return immediately.
}
\section{Condition}{


    The condition internal to this 'conditionVariable' maintains a state
    (counter). Each signal increments the counter by 1. Each time
    \code{wait} or \code{until} returns (apart from due to timeout), the
    counter is decremented by 1.

    The internal condition may be inspected at any time using \code{cv_value},
    adjusted using \code{cv_adjust} and reset to zero using \code{cv_reset}.
    This affords a high degree of flexibility in designing complex concurrent
    applications.
}

\section{Flag}{


    The condition variable also contains a flag that certain signalling
    functions such as \code{\link{pipe_notify}} can set. When this flag has
    been set, all subsequent \code{wait} or \code{until} calls will return
    logical FALSE instead of TRUE.

    Note that the flag is not automatically reset, but may be reset manually
    using \code{cv_reset}.
}

\examples{
cv <- cv()

# wait(cv) # uncommenting will block until the cv is signalled

until(cv, 10L)

cv_value(cv)

cv_adjust(cv, 2L)
cv_value(cv)

cv_reset(cv)
cv_value(cv)

}
