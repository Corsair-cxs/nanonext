% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{reply}
\alias{reply}
\title{Reply over Context (Server for Req/Rep Protocol)}
\usage{
reply(
  context,
  execute,
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  send_mode = c("serial", "raw"),
  timeout,
  ...
)
}
\arguments{
\item{context}{a Context.}

\item{execute}{a function which takes the received (converted) data as its
first argument. Can be an anonymous function of the form \code{function(x) do(x)}.
Additional arguments can also be passed in through '...'.}

\item{recv_mode}{[default 'serial'] mode of vector to be received - one of 'serial',
'character', 'complex', 'double', 'integer', 'logical', 'numeric', or 'raw'.
The default 'serial' means a serialised R object, for the other modes,
the raw vector received will be converted into the respective mode.}

\item{send_mode}{[default 'serial'] whether data will be sent serialized or
as a raw vector. Use 'serial' for sending and receiving within R to ensure
perfect reproducibility. Use 'raw' for sending vectors of any type (will be
converted to a raw byte vector for sending) - essential when interfacing
with external applications.}

\item{timeout}{in ms. If unspecified, a socket-specific default timeout will
be used. Note this applies to each of the receive and send legs, hence the
total elapsed time could be up to twice this parameter plus the time to
perform 'execute' on the received data.}

\item{...}{additional arguments passed to the function specified by 'execute'.}
}
\value{
Invisible NULL.
}
\description{
Implements an executor/server for the rep node of the req/rep protocol. Awaits
    data, applies an arbitrary specified function, and returns the result
    to the caller/client.
}
\details{
Receive will block while awaiting a message to arrive and is usually
    the desired behaviour. Set a timeout to allow the function to return
    if no data is forthcoming.

    In the event of an error in unserialisation or conversion of the
    received message, in the evaluation of the function with respect to the
    data, or in the serialization or conversion of the message to be sent,
    a NULL byte (or serialized NULL byte) will be sent in reply to signal an
    error to the client.
}
\examples{
req <- socket("req", listen = "tcp://127.0.0.1:6546")
rep <- socket("rep", dial = "tcp://127.0.0.1:6546")

ctxq <- context(req)
ctxp <- context(rep)

send_ctx(ctxq, 2022, timeout = 100, echo = FALSE)
reply(ctxp, execute = function(x) x + 1, send_mode = "raw", timeout = 100)
recv_ctx(ctxq, mode = "double", timeout = 100, keep.raw = FALSE)

send_ctx(ctxq, 100, mode = "raw", timeout = 100, echo = FALSE)
reply(ctxp, recv_mode = "double", execute = log, base = 10, timeout = 100)
recv_ctx(ctxq, timeout = 100, keep.raw = FALSE)

close(req)
close(rep)

}
