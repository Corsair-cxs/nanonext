% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{context}
\alias{context}
\alias{ctx}
\title{Open Context}
\usage{
context(socket, ...)

ctx(socket)
}
\arguments{
\item{socket}{a Socket.}

\item{...}{not used, present for compatibility purposes only.}
}
\value{
For context: a new Context (object of class 'nanoContext' and 'nano').

    For ctx: an external pointer.
}
\description{
Open a new Context to be used with a Socket. The purpose of a Context is to
    permit applications to share a single socket, with its underlying dialers
    and listeners, while still benefiting from separate state tracking.
    \code{ctx} is a performance variant of \code{context}, designed to wrap a
    socket in a function argument when calling \code{\link{request}} or
    \code{\link{reply}}, rather than returning an object.
}
\details{
Contexts allow the independent and concurrent use of stateful
    operations using the same socket. For example, two different contexts
    created on a rep socket can each receive requests, and send replies to
    them, without any regard to or interference with each other.

    Only the following protocols support creation of contexts: req, rep, sub
    (in a pub/sub pattern), surveyor, respondent.

    To send and receive over a context use \code{\link{send}} and
    \code{\link{recv}} or their async counterparts \code{\link{send_aio}} and
    \code{\link{recv_aio}}.

    For nano objects, use the \code{$context_open()} method, which will
    attach a new context at \code{$context}. See \code{\link{nano}}.

    For external pointers created by \code{ctx}, these are unclassed, hence
    methods for contexts such as \code{\link{close}} will not work. However
    they function as a Context would when passed to all messaging functions.
    The context is automatically closed when the object is garbage collected.
}
\examples{
s <- socket("req", listen = "inproc://nanonext")
ctx <- context(s)
ctx
close(ctx)
r <- request(ctx(s), "request data")
close(s)

n <- nano("req", listen = "inproc://nanonext")
n$context_open()
n$context
n$context_open()
n$context
n$context_close()
n$close()

}
