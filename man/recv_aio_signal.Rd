% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aio.R
\name{recv_aio_signal}
\alias{recv_aio_signal}
\title{Receive Async and Signal a Condition}
\usage{
recv_aio_signal(
  con,
  mode = c("serial", "character", "complex", "double", "integer", "logical", "numeric",
    "raw"),
  timeout = NULL,
  keep.raw = FALSE,
  n = 65536L,
  cv
)
}
\arguments{
\item{con}{a Socket, Context or Stream.}

\item{mode}{[default 'serial'] mode of vector to be received - one of 'serial',
'character', 'complex', 'double', 'integer', 'logical', 'numeric', or 'raw'.
The default 'serial' means a serialised R object, for the other modes,
the raw vector received will be converted into the respective mode.
For Streams, 'serial' is not an option and the default is 'character'.
Alternatively, for performance, specify an integer position in the vector
of choices e.g. 1L for 'serial', 2L for 'character' etc.}

\item{timeout}{[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout.}

\item{keep.raw}{[default FALSE] logical flag whether to keep and return the
received raw vector along with the converted data. Supplying a non-logical
value will error.}

\item{n}{[default 65536L] applicable to Streams only, the maximum number of
bytes to receive. Can be an over-estimate, but note that a buffer of this
size is reserved.}

\item{cv}{a condition variable that should be signalled when the reply is
received.}
}
\value{
A 'recvAio' (object of class 'recvAio') (invisibly).
}
\description{
Implements a signalling version of \code{\link{recv_aio}} to receive data
    asynchronously over a connection (Socket, Context or Stream).
}
\details{
Async receive is always non-blocking and returns a 'recvAio'
    immediately.

    For a 'recvAio', the received message is available at \code{$data}, and
    the raw message at \code{$raw} (if kept). An 'unresolved' logical NA is
    returned if the async operation is yet to complete.

    In case of an error, an integer 'errorValue' is returned (to be
    distiguishable from an integer message value). This can be verified using
    \code{\link{is_error_value}}.

    If the raw message was successfully received but an error occurred in
    unserialisation or data conversion (for example if the incorrect mode was
    specified), the received raw vector will be stored at \code{$data} to
    allow for the data to be recovered.

    When the receive is complete, the supplied condition variable is
    signalled by incrementing it by 1.
}
\examples{
s1 <- socket("pair", listen = "abstract://nanonext")
cv <- cv()
msg <- recv_aio_signal(s1, timeout = 100, cv = cv)
until(cv, 10L)
msg$data
close(s1)

# in another process in parallel
s2 <- socket("pair", dial = "abstract://nanonext")
res <- send_aio(s2, c(1.1, 2.2, 3.3), mode = "raw", timeout = 100)
close(s2)

}
