% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{cv_request}
\alias{cv_request}
\title{Request over Context and Signal a Condition Variable}
\usage{
cv_request(
  context,
  data,
  send_mode = c("serial", "raw"),
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  timeout = NULL,
  keep.raw = FALSE,
  cv
)
}
\arguments{
\item{context}{a Context.}

\item{data}{an object (if send_mode = 'raw', a vector).}

\item{send_mode}{[default 'serial'] whether data will be sent serialized or
as a raw vector. Use 'serial' for sending and receiving within R to ensure
perfect reproducibility. Use 'raw' for sending vectors of any type
(converted to a raw byte vector for sending) - essential when interfacing
with external applications. Alternatively, for performance, specify an
integer position in the vector of choices i.e. 1L for 'serial' or 2L for
'raw'.}

\item{recv_mode}{[default 'serial'] mode of vector to be received - one of
'serial', 'character', 'complex', 'double', 'integer', 'logical',
'numeric', or 'raw'. The default 'serial' means a serialised R object,
for the other modes, the raw vector received will be converted into the
respective mode. Alternatively, for performance, specify an integer
position in the vector of choices e.g. 1L for 'serial', 2L for 'character'
etc.}

\item{timeout}{[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout. Note
that this applies to receiving the result.}

\item{keep.raw}{[default FALSE] logical flag whether to keep and return the
received raw vector along with the converted data. Supplying a non-logical
value will error.}

\item{cv}{a condition variable that should be signalled when the reply is
received.}
}
\value{
A 'recvAio' (object of class 'recvAio') (invisibly).
}
\description{
Implements a caller/client for the req node of the req/rep protocol. Sends
    data to the rep node (executor/server) and returns an Aio, which can be
    called when the result is required. When the result is received, the
    supplied condition variable is signalled, causing threads waiting on the
    condition variable to wake.
}
\details{
Sending the request and receiving the result are both performed async,
    hence the function will return immediately with a 'recvAio' object. Access
    the return value at \code{$data}.

    This is designed so that the process on the server can run concurrently
    without blocking the client.
}
\examples{
req <- socket("req", listen = "tcp://127.0.0.1:6546")
ctxq <- context(req)
cv <- cv_new()
aio <- cv_request(ctxq, data = 2022, timeout = 10, cv = cv)
# cv_wait(cv) # uncommenting will block until the cv is signalled
close(req)

# The following should be run in another process
# rep <- socket("rep", dial = "tcp://127.0.0.1:6546")
# ctxp <- context(rep)
# reply(ctxp, execute = function(x) x + 1, timeout = 10)
# close(rep)

}
