library(nanonext)
test_true <- function(x) invisible(isTRUE(x) || {print(x); stop("the above was returned instead of TRUE")})
test_truew <- function(x) invisible(suppressWarnings(isTRUE(x)) || {print(x); stop("the above was returned instead of TRUE")})
test_zero <- function(x) invisible(x == 0L || {print(x); stop("the above was returned instead of 0L")})
test_equal <- function(a, b) invisible(a == b || {print(a); print(b); stop("the above arguments were not equal")})
test_identical <- function(a, b) invisible(identical(a, b) || {print(a); print(b); stop("the above arguments were not identical")})
test_aio <- function(x) invisible(is_aio(x) || {print(x); stop("the above was returned instead of an Aio object")})
test_nano <- function(x) invisible(is_nano(x) || {print(x); stop("the above was returned instead of an object of class 'nano'")})
test_null <- function(x) invisible(is.null(x) || {print(x); stop("the above was returned instead of NULL")})
test_notnull <- function(x) invisible(!is.null(x) || stop("is NULL when expected to be not NULL"))
test_print <- function(x) invisible(is.character(capture.output(print(x))) || stop("print output of expression could not be captured as a character value"))
test_xptr <- function(x) invisible(typeof(x) == "externalptr" || {print(x); stop("the above was returned instead of an external pointer")})
test_errorvalue <- function(x) invisible(is_error_value(x) || {print(x); stop("the above was returned instead of an 'errorValue'")})
test_error <- function(x, e = "") {
  x <- tryCatch(x, error = identity)
  inherits(x, "error") && grepl(e, x[["message"]], fixed = TRUE) || stop("expected error message containing '", e, "' was not generated")
  invisible(TRUE)
}
later <- requireNamespace("later", quietly = TRUE)
promises <- requireNamespace("promises", quietly = TRUE)

nng_version()
test_nano(n <- nano("req", listen = "inproc://nanonext", autostart = FALSE))
test_nano(n1 <- nano("rep", dial = "inproc://nanonext", autostart = FALSE))
test_true(inherits(n, "nanoObject"))
test_true(inherits(n$socket, "nanoSocket"))
test_true(inherits(n$socket, "nano"))
test_nano(n)
n$newmethod <- "doesnotwork"
test_null(n$newmethod)
test_true(is.integer(attr(n$socket, "id")))
test_equal(n$socket$state, "opened")
test_equal(n$socket$protocol, "req")
test_equal(n$send("not ready", mode = "serial"), 8L)
test_equal(n$recv(), 11L)
test_nano(n$opt("recv-size-max", 8192))
test_equal(n$opt("recv-size-max"), 8192L)
test_nano(n$opt("recv-buffer", 8L))
test_nano(n$opt("req:resend-time", 0L))
test_nano(n$opt("socket-name", "nano"))
test_equal(n$opt("socket-name"), "nano")
test_error(n$opt("socket-name", NULL), "argument")
test_print(n$listener[[1]])
test_true(inherits(n$listener[[1]], "nanoListener"))
test_equal(n$listener[[1]]$url, "inproc://nanonext")
test_equal(n$listener[[1]]$state, "not started")
test_nano(n$listener_opt("recv-size-max", 1024)[[1L]])
test_equal(n$listener_opt("recv-size-max")[[1L]], 1024L)
test_error(n$listener_opt("false", 100), "supported")
test_error(n$listener_opt("false"), "supported")
test_error(n$listener_opt("false", "false"), "supported")
test_error(n$listener_opt("false", NULL), "supported")
test_error(n$listener_opt("false", TRUE), "supported")
test_error(n$listener_opt("false", list()), "type")
test_zero(n$listener_start())
test_equal(n$listener[[1]]$state, "started")
test_print(n1$dialer[[1]])
test_true(inherits(n1$dialer[[1]], "nanoDialer"))
test_equal(n1$dialer[[1]]$url, "inproc://nanonext")
test_equal(n1$dialer[[1]]$state, "not started")
test_nano(n1$dialer_opt("reconnect-time-min", 1000)[[1L]])
test_equal(n1$dialer_opt("reconnect-time-min")[[1L]], 1000L)
test_nano(n1$dialer_opt("recv-size-max", 8192)[[1L]])
test_equal(n1$dialer_opt("recv-size-max")[[1L]], 8192L)
test_error(n1$dialer_opt("false", 100), "supported")
test_error(n1$dialer_opt("false"), "supported")
test_error(n1$dialer_opt("false", "false"), "supported")
test_error(n1$dialer_opt("false", NULL), "supported")
test_error(n1$dialer_opt("false", TRUE), "supported")
test_error(n1$dialer_opt("false", list()), "type")
test_zero(n1$dialer_start())
test_equal(n1$dialer[[1]]$state, "started")

test_error(n$send(list(), mode = "raw"), "atomic vector type")
test_error(n$recv(mode = "none"), "mode")
test_error(n$recv(mode = "c"), "mode")
test_aio(raio <- n1$recv_aio(timeout = 1L))
test_print(raio)
test_errorvalue(call_aio(raio)$data)
test_errorvalue(raio$data)
r <- n$send(data.frame(), block = FALSE)
if (r == 8L) r <- n$send(data.frame(), block = 500L)
test_zero(r)
test_true(is.data.frame(n1$recv(block = 500)))
test_zero(n1$send(c("test", "", "spec"), mode = "raw", block = 500))
test_identical(n$recv("character", block = 500), c("test", "", "spec"))
test_zero(n$send(1:5, mode = "r"))
test_equal(length(n1$recv("int", block = 500)), 5L)
test_aio(saio <- n1$send_aio(paste(replicate(5, random(1e3L)), collapse = ""), mode = 1L, timeout = 900))
test_print(saio)
test_aio(call_aio(saio))
test_zero(saio$result)
test_error(n$send("wrong mode", mode = "none"), "mode")
test_aio(raio <- n$recv_aio(timeout = 500))
test_print(raio)
test_equal(nchar(call_aio(raio)[["value"]]), 10000L)
raio$newfield <- "doesnotwork"
raio[["newfield"]] <- "doesnotwork"
test_null(raio$newfield)
test_aio(saio <- n$send_aio(c(1.1, 2.2), mode = "raw", timeout = 500))
saio$newfield <- "doesnotwork"
saio[["newfield"]] <- "doesnotwork"
test_null(saio$newfield)
test_true(is.logical(unresolved(saio)))
test_true(is.logical(.unresolved(saio)))
test_aio(msg <- n1$recv_aio(mode = "numer", timeout = 500))
test_identical(call_aio(msg), msg)
test_aio(msg <- n1$recv_aio(mode = "complex", timeout = 500))
test_null(stop_aio(msg))
test_null(stop_aio(n))
test_identical(call_aio(msg), msg)
test_errorvalue(msg$data)
test_identical(call_aio(n), n)
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "r", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = 1L, timeout = 500))
test_true(is_nul_byte(call_aio_(rraio)$data))
test_aio(sraio <- n$send_aio(as.raw(1L), mode = "ra", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "raw", timeout = 500))
test_true(is.raw(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(c(1+2i, 4+3i), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "co", timeout = 500))
test_true(is.complex(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(5, mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "d", timeout = 500))
test_true(is.double(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(c(1, 2), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "n", timeout = 500))
test_true(is.numeric(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(c(1L, 2L, 3L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "i", timeout = 500))
test_true(is.integer(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "double", timeout = 500))
test_true(is.raw(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "int", timeout = 500))
test_true(is.raw(call_aio(rraio)$data))
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "logical", timeout = 500))
test_truew(is.raw(collect_aio(rraio)))
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "numeric", timeout = 500))
test_true(is.raw(rraio[]))
test_aio(sraio <- n$send_aio(as.raw(0L), mode = "raw", timeout = 500))
test_aio(rraio <- n1$recv_aio(mode = "complex", timeout = 500))
test_true(is.raw(collect_aio_(rraio)))
test_error(opt(rraio[["aio"]], "false") <- 0L, "valid")
test_error(subscribe(rraio[["aio"]], "false"), "valid")
test_error(opt(rraio[["aio"]], "false"), "valid")
test_error(stat(rraio[["aio"]], "pipes"), "valid")

test_zero(n$dial(url = "inproc://two", autostart = FALSE))
test_zero(n$dialer_start())
test_true(inherits(n$dialer[[1L]], "nanoDialer"))
test_true(is.double(stat(n$dialer[[1L]], "id")))
test_zero(n$listen(url = "inproc://three", autostart = FALSE))
test_zero(n$listener_start())
test_true(inherits(n$listener[[2L]], "nanoListener"))
test_true(is.double(stat(n$listener[[2L]], "id")))
test_zero(n$dial(url = "inproc://four"))
test_zero(close(n$listener[[1]]))
test_truew(close(n$listener[[1]]) == 12L)
test_zero(close(n1$dialer[[1]]))
test_truew(close(n1$dialer[[1]]) == 12L)
test_zero(reap(n$listener[[2]]))
test_zero(reap(n$dialer[[2]]))
test_zero(n$close())
test_zero(n1$close())
test_truew(n1$close() == 7L)
test_equal(n$socket[["state"]], "closed")
test_equal(n1$socket[state], "closed")

test_true(inherits(cv <- cv(), "conditionVariable"))
test_print(cv)
test_xptr(cv2 <- cv())
test_true(!until(cv, 10L))
test_true(!until(cv, 10))
test_true(!until_(cv, 10L))
test_true(!until_(cv, 10))
test_true(!until_(cv, "test"))
test_zero(cv_reset(cv))
test_zero(cv_value(cv))

test_nano(req <- nano("req", listen = "inproc://testing"))
test_nano(rep <- socket("rep", dial = "inproc://testing", listen = "inproc://testing2"))
test_print(rep)
test_equal(stat(rep, "dialers"), 1)
test_equal(stat(rep, "protocol"), "rep")
test_null(stat(rep, "nonexistentstat"))
test_nano(req$opt("req:resend-time", 1000))
test_equal(req$opt("req:resend-time"), 1000L)
test_error(req$opt("none"), "supported")
test_xptr(req$context_open())
test_true(inherits(req$context, "nanoContext"))
test_true(inherits(req$context, "nano"))
test_true(is.integer(req$context$id))
test_equal(req$context$state, "opened")
test_equal(req$context$protocol, "req")
test_nano(req$opt("send-timeout", 1000))
test_equal(req$opt("send-timeout"), 1000L)
test_error(req$opt("false", 100), "supported")
test_error(req$opt("false"), "supported")
test_error(req$opt("false", "false"), "supported")
test_error(req$opt("false", NULL), "supported")
test_error(req$opt("false", TRUE), "supported")
test_error(req$opt("false", list()), "type")

test_aio(r <- recv_aio(rep, timeout = 500))
test_zero(req$send("", block = 500))
test_print(p <- tryCatch(collect_pipe(r), error = function(e) NULL))
if (!is.null(p)) test_true(is_nano(p))
test_true(.mark())
test_aio(r <- send_aio(if (is_nano(p)) p else rep, "", timeout = 500))
if (later) test_null(.keep(r, new.env()))
test_error(collect_pipe(r), "valid")
test_equal(req$recv(mode = 8L, block = 500)[4L], 1L)
test_true(!.mark(FALSE))

test_nano(ctx <- context(rep))
test_print(ctx)
test_aio(csaio <- req$send_aio(data.frame(), mode = "seria", timeout = 500))
test_zero(call_aio_(csaio)$result)
test_aio(craio <- recv_aio(ctx, timeout = 500))
test_true(is.list(collect_aio(craio)))
test_zero(req$send("context test", mode ="raw", block = 500))
test_equal(recv(ctx, mode = "string", block = 500), "context test")
test_notnull(req$send(data.frame(), mode = "seri", block = 500))
test_aio(msg <- recv_aio(ctx, mode = "ser", timeout = 500))
test_true(is.logical(.unresolved(msg)))
test_true(is.logical(unresolved(msg)))
test_true(is.data.frame(call_aio(msg)$data))
test_true(!unresolved(msg))
test_zero(req$send(c(TRUE, FALSE, TRUE), mode = 2L, block = 500))
test_aio(msg <- recv_aio(ctx, mode = 6L, timeout = 500))
test_true(is.logical(msg[]))
test_identical(collect_aio(msg), collect_aio_(msg))
test_aio(err <- send_aio(ctx, msg[["data"]], mode = "serial"))
test_null(stop_aio(err))
test_aio(err <- send_aio(ctx, "test"))
test_errorvalue(call_aio(err)$result)
test_errorvalue(call_aio(list(err))[[1L]][["result"]])
test_errorvalue(call_aio_(err)$result)
test_errorvalue(call_aio_(list(item = err))[["item"]][["result"]])
test_errorvalue(collect_aio(err))
test_errorvalue(collect_aio(list(item = err))[["item"]])
test_errorvalue(collect_aio_(list(err))[[1L]])
test_zero(req$send(serialize(NULL, NULL, ascii = TRUE), mode = 2L, block = 500))
test_null(call_aio(recv_aio(ctx, mode = 1L, timeout = 500))[["value"]])
test_aio(saio <- send_aio(ctx, as.raw(1L), mode = 2L, timeout = 500))
test_identical(req$recv(mode = 8L, block = 500), as.raw(1L))
test_aio(rek <- request(req$context, c(1+3i, 4+2i), send_mode = 2L, recv_mode = "complex", timeout = 500))
test_zero(reply(ctx, execute = identity, recv_mode = 3L, send_mode = "ra", timeout = 500))
test_true(is.complex(call_aio(rek)[["data"]]))
test_aio(rek <- request(req$context, c(1+3i, 4+2i), send_mode = "serial", recv_mode = "serial", timeout = 500))
test_zero(reply(ctx, execute = identity, recv_mode = 1L, send_mode = 1L, timeout = 500))
test_true(is.complex(call_aio(rek)[["data"]]))

test_true(is.list(cfg <- serial_config(class = "custom", sfunc = function(x) raw(1L), ufunc = as.integer, vec = FALSE)))
test_equal(length(cfg), 4L)
test_true(is.function(cfg[[2L]]))
opt(req$socket, "serial") <- cfg
opt(rep, "serial") <- cfg
custom <- list(`class<-`(new.env(), "custom"), new.env())
test_zero(send(req$socket, custom, mode = "serial", block = 500))
test_true(is.integer(recv(rep, block = 500)[[1L]]))
cfg <- serial_config("custom", function(x) as.raw(length(x)), function(x) lapply(seq_len(as.integer(x)), new.env), vec = TRUE)
opt(req$socket, "serial") <- cfg
opt(rep, "serial") <- cfg
test_zero(send(rep, custom, block = 500))
test_true(is.list(recv(req$socket, mode = 1L, block = 500)))
opt(req$socket, "serial") <- list()
opt(rep, "serial") <- list()
test_error(serial_config("custom", "func1", "func2"), "must be functions")
test_error(opt(rep, "wrong") <- cfg, "not supported")
test_error(opt(rep, "serial") <- pairlist(a = 1L), "not supported")
test_error(opt(rep, "serial") <- list("wrong"), "Invalid argument")

test_aio(cs <- request(req$context, "test", send_mode = "serial", cv = cv, timeout = 500))
test_notnull(cs$data)
test_xptr(ctxn <- .context(rep))
test_aio(cr <- recv_aio(ctxn, cv = cv, timeout = 500))
test_equal(call_aio(cr)$data, "test")
test_true(is.integer(send(ctxn, TRUE, mode = 0L, block = FALSE)))
test_xptr(ctxn <- .context(rep))
test_aio(cs <- request(.context(req$socket), data = TRUE, cv = NA))
test_notnull(cs$data)
test_true(recv(ctxn, block = 500))
test_zero(send(ctxn, TRUE, mode = 1L, block = 500))
test_zero(reap(ctxn))
test_equal(reap(ctxn), 7L)
test_zero(pipe_notify(rep, cv, add = TRUE, flag = TRUE))
test_zero(pipe_notify(rep, cv, remove = TRUE, flag = tools::SIGCONT))
test_zero(pipe_notify(req$socket, cv = cv, add = TRUE))
test_zero(pipe_notify(req$socket, cv = cv, cv2 = cv2, remove = TRUE, flag = tools::SIGCONT))
test_error(request(err, "test", cv = cv), "valid")
test_error(recv_aio(err, cv = cv, timeout = 500))
test_error(wait(err), "valid")
test_error(wait_(err), "valid")
test_error(until(err, 10), "valid")
test_error(until_(err, 10), "valid")
test_error(cv_value(err), "valid")
test_error(cv_reset(err), "valid")
test_error(cv_signal(err), "valid")
test_error(collect_pipe(err), "valid")
test_error(pipe_notify(err, cv), "valid Socket")
test_error(pipe_notify(rep, err), "valid Condition Variable")
test_error(pipe_notify(rep, cv, err), "valid Condition Variable")
test_zero(req$context_close())
test_null(req$context_close)
test_zero(req$close())
test_null(req$context)
rep$dialer <- NULL
test_xptr(rep$dialer[[1L]])
test_zero(close(ctx))
if (is_nano(p)) test_equal(reap(p), 12L)
if (is_nano(p)) test_truew(close(p) == 12L)

test_nano(pub <- nano("pub", listen = "inproc://ps"))
test_nano(sub <- nano("sub", dial = "inproc://ps", autostart = NA))
test_zero(cv_reset(cv))
test_zero(cv_reset(cv2))
test_zero(pipe_notify(pub$socket, cv, cv2, add = TRUE, remove = TRUE))
test_nano(sub$opt(name = "sub:prefnew", value = FALSE))
test_true(!sub$opt(name = "sub:prefnew"))
test_error(sub$opt(name = "false", value = 100), "supported")
test_error(sub$opt(name = "false"), "supported")
test_error(sub$opt(name = "false", value = list()), "type")
test_nano(sub$subscribe("test"))
test_nano(subscribe(sub$socket, NULL))
test_nano(sub$unsubscribe("test"))
test_xptr(sub$context_open())
test_true(inherits(sub$context, "nanoContext"))
test_nano(sub$subscribe(12))
test_nano(sub$unsubscribe(12))
test_nano(sub$subscribe(NULL))
test_zero(sub$context_close())
test_null(sub$context)
test_zero(sub$close())
test_zero(pub$close())
test_true(wait(cv))
test_true(wait(cv2))
test_xptr(cv3 <- cv())
test_xptr(cv %~>% cv2 %~>% cv3)
test_zero(cv_signal(cv))
test_equal(cv_value(cv), 1L)
test_true(wait_(cv3))
test_xptr(cv %~>% cv3)
test_error("a" %~>% cv3, "valid Condition Variable")
test_error(cv3 %~>% "a", "valid Condition Variable")

test_nano(surv <- nano(protocol = "surveyor", listen = "inproc://sock1", dial = "inproc://sock2"))
test_print(surv)
test_nano(resp <- nano(protocol = "respondent", listen = "inproc://sock2", dial = "inproc://sock1"))
test_zero(pipe_notify(surv$socket, cv, cv2, add = TRUE, remove = TRUE, flag = TRUE))
surv$dialer <- NULL
test_xptr(surv$dialer[[1L]])
test_xptr(surv$listener[[1L]])
test_nano(surv$survey_time(5000))
test_xptr(surv$context_open())
test_xptr(resp$context_open())
test_nano(surv$survey_time(value = 2000))
test_zero(surv$context_close())
test_zero(resp$context_close())
test_zero(surv$close())
test_zero(resp$close())
test_true(!wait(cv))
test_true(!wait(cv2))
test_errorvalue(resp$recv())

test_true(inherits(bus <- socket(protocol = "bus"), "nanoSocket"))
test_true(inherits(push <- socket(protocol = "push"), "nanoSocket"))
test_true(inherits(pull <- socket(protocol = "pull"), "nanoSocket"))
test_true(inherits(pair <- socket(protocol = "pair"), "nanoSocket"))
test_true(inherits(poly <- socket(protocol = "poly"), "nanoSocket"))
test_nano(bus)
test_truew(listen(bus, url = "test") == 3L)
test_truew(dial(bus, url = "test") == 3L)
test_error(listen(bus, url = "tls+tcp://localhost/:0", tls = "wrong"), "valid TLS")
test_error(dial(bus, url = "tls+tcp://localhost/:0", tls = "wrong"), "valid TLS")
test_zero(close(bus))
test_truew(close(bus) == 7L)
test_zero(close(push))
test_zero(close(pull))
test_zero(reap(pair))
test_zero(reap(poly))
test_error(socket(protocol = "newprotocol"), "protocol")
test_error(socket(dial = "test"), "argument")
test_error(socket(listen = "test"), "argument")

test_notnull(ncurl("http://www.cam.ac.uk/"))
test_notnull(ncurl("http://www.cam.ac.uk/", follow = FALSE, response = "date"))
test_notnull(ncurl("http://www.cam.ac.uk/", follow = TRUE))
test_notnull(ncurl("http://postman-echo.com/post", convert = FALSE, method = "POST", headers = c(`Content-Type` = "text/plain"), data = "test", response = c("Date", "Server"), timeout = 3000))
test_errorvalue(ncurl("http")$data)
haio <- ncurl_aio("http://example.com/")
test_true(is.integer(call_aio(haio)$status))
haio <- ncurl_aio("https://example.com/", convert = FALSE, response = "server")
test_notnull(haio$status)
if (call_aio(haio)$status == 200L) test_notnull(haio$headers)
put1 <- ncurl_aio("http://postman-echo.com/put", method = "PUT", headers = c(Authorization = "Bearer token"), data = "test", response = c("Date", "server"), timeout = 3000L)
test_print(put1)
test_true(is.integer(call_aio_(put1)$status))
if (put1$status == 200L) test_notnull(put1$headers)
if (put1$status == 200L) test_notnull(put1$data)
test_null(stop_aio(put1))
haio <- ncurl_aio("https://i.i")
test_errorvalue(call_aio(haio)$data)
test_print(haio$data)
ncaio <- ncurl_aio("https://shikokuchuo.net/nanonext/reference/figures/logo.png")
if (call_aio(ncaio)$status == 200L) test_true(is.raw(ncaio$data))
test_errorvalue(ncurl_aio("http")$data)
sess <- ncurl_session("https://postman-echo.com/post", method = "POST", headers = c(`Content-Type` = "text/plain"), data = "test", response = c("date", "Server"), timeout = 3000L)
test_true(is_ncurl_session(sess) || is_error_value(sess))
if (is_ncurl_session(sess)) test_equal(length(transact(sess)), 3L)
if (is_ncurl_session(sess)) test_zero(close(sess))
if (is_ncurl_session(sess)) test_truew(close(sess) == 7L)
sess <- ncurl_session("https://postman-echo.com/post", convert = FALSE, method = "POST", headers = c(`Content-Type` = "text/plain"), timeout = 3000)
test_true(is_ncurl_session(sess) || is_error_value(sess))
if (is_ncurl_session(sess)) test_equal(length(transact(sess)), 3L)
if (is_ncurl_session(sess)) test_zero(close(sess))
if (is_ncurl_session(sess)) test_equal(transact(sess)$data, 7L)
test_truew(is_error_value(ncurl_session("https://i")))
test_error(ncurl_aio("https://", tls = "wrong"), "valid TLS")
test_error(ncurl("https://www.example.com/", tls = "wrong"), "valid TLS")
test_xptr(etls <- tls_config())
test_error(stream(dial = "wss://127.0.0.1:5555", textframes = TRUE, tls = etls))
test_error(stream(dial = "wss://127.0.0.1:5555"))
test_error(stream(dial = "errorValue3"), "argument")
test_error(stream(dial = "inproc://notsup"), "Not supported")
test_error(stream(dial = "wss://127.0.0.1:5555", tls = "wrong"), "valid TLS")
test_error(stream(listen = "errorValue3"), "argument")
test_error(stream(listen = "inproc://notsup"), "Not supported")
test_error(stream(listen = "errorValue3", tls = "wrong"), "valid TLS")
test_error(stream(), "specify")

test_true(is.character(ver <- nng_version()))
test_equal(length(ver), 2L)
test_equal(nng_error(8L), "8 | Try again")
test_true(is_nul_byte(as.raw(0L)))
test_true(!is_nul_byte(NULL))
test_true(!is_error_value(1L))
test_error(messenger("invalidURL"), "argument")
test_true(is.raw(md5 <- nanonext:::md5_object("secret base")))
test_equal(length(md5), 32L)
test_true(is.double(mclock()))
test_null(msleep(1L))
test_null(msleep(1))
test_null(msleep("a"))
test_true(is.character(urlp <- parse_url("://")))
test_equal(length(urlp), 10L)
test_true(all(nzchar(parse_url("wss://use:r@[::1]/path?q=1#name"))))
test_true(is.character(random()))
test_equal(nchar(random(2)), 4L)
test_equal(length(random(4L, convert = FALSE)), 4L)
test_error(random(1025), "between 0 and 1024")
test_error(random(-1), "between 0 and 1024")
test_error(random("test"), "integer")
test_error(parse_url("tcp:/"), "argument")
for (i in c(100:103, 200:208, 226, 300:308, 400:426, 428:431, 451, 500:511, 600))
  test_true(is.character(status_code(i)))

s <- tryCatch(stream(dial = "wss://echo.websocket.events/", textframes = TRUE), error = function(e) NULL)
is_nano(s) && {
  test_notnull(recv(s, block = 500L))
  test_true(is.character(opt(s, "ws:response-headers")))
  test_error(opt(s, "ws:request-headers") <- "test\n", 24)
  test_true(is.integer(send(s, c("message1", "test"), block = 500L)))
  test_notnull(recv(s, block = FALSE))
  test_true(is.integer(send(s, "message2", block = FALSE)))
  test_notnull(recv(s, mode = 9L, block = 100))
  test_true(is.integer(send(s, 2L, block = 500)))
  test_aio(sr <- recv_aio(s, mode = "i", timeout = 500L, n = 8192L))
  test_notnull(call_aio(sr)[["data"]])
  test_null(stop_aio(sr))
  test_aio(ss <- send_aio(s, "async", timeout = 500L))
  test_true(is.integer(ss[]))
  test_null(stop_aio(ss))
  test_true(is.integer(send(s, 12.56, mode = "raw", block = 500L)))
  test_aio(sr <- recv_aio(s, mode = "double", timeout = 500L, cv = cv))
  test_notnull(call_aio_(sr)[["data"]])
  test_true(cv_value(cv) > 0L)
  test_true(is.character(opt(s, "ws:request-headers")))
  test_notnull(opt(s, "tcp-nodelay") <- FALSE)
  test_error(recv(s, mode = "none", block = FALSE), "should be one of character")
  test_error(recv(s, mode = "c", block = FALSE), "should be one of character")
  test_error(opt(s, "none"), "supported")
  test_error(`opt<-`(s, "none", list()), "supported")
  test_print(s)
  test_true(is.integer(close(s)))
}

test_nano(s <- socket("bus", listen = "inproc://nanolock"))
test_nano(s1 <- socket("bus", dial = "inproc://nanolock"))
test_zero(lock(s))
test_nano(s2 <- socket("bus", dial = "inproc://nanolock"))
test_aio(send_aio(s, "test"))
test_notnull(recv(s1, block = 500))
test_errorvalue(recv(s2))
test_zero(unlock(s))
test_zero(pipe_notify(s, cv = cv, add = TRUE, remove = TRUE))
test_zero(lock(s, cv = cv))
test_nano(s3 <- socket("bus", dial = "inproc://nanolock"))
test_zero(send(s, "test", block = 500))
test_notnull(recv(s3, block = 500))
test_error(unlock(cv), "valid Socket")
test_error(lock(cv), "valid Socket")
test_error(lock(s, cv = s), "valid Condition Variable")
test_zero(pipe_notify(s, cv = NULL, add = TRUE, remove = TRUE))
test_zero(close(s))
test_zero(close(s1))
test_zero(close(s2))
test_zero(close(s3))

test_xptr(cv <- cv())
test_error(.dispatcher(host = "inproc://hostdisp", url = "inproc://disp/1", tls = ""), "not a valid TLS Configuration")
test_xptr(disp <- .dispatcher(host = "inproc://hostdisp", url = "inproc://disp/1", tls = NULL))
test_zero(.online(disp))
test_null(.online("a"))
test_nano(s <- socket(protocol = "rep"))
test_zero(pipe_notify(s, cv, add = TRUE))
test_zero(dial(s, url = "inproc://disp/1"))
test_true(wait(cv))
test_zero(send(disp, NULL, block = 500L))
test_null(recv(s, block = 500L))
test_zero(send(s, TRUE, block = 500L))
test_true(recv(disp, block = 500L))
test_zero(close(s))
rm(disp)

test_true(nanonext:::.DollarNames.ncurlAio(NULL, "sta") == "status")
test_true(nanonext:::.DollarNames.recvAio(NULL, "dat") == "data")
test_true(nanonext:::.DollarNames.sendAio(NULL, "r") == "result")
test_true(length(nanonext:::.DollarNames.nano(NULL)) == 0L)

fakesock <- `class<-`(new.env(), "nanoSocket")
test_error(dial(fakesock), "valid Socket")
test_error(dial(fakesock, autostart = FALSE), "valid Socket")
test_error(listen(fakesock), "valid Socket")
test_error(listen(fakesock, autostart = FALSE), "valid Socket")
test_error(context(fakesock), "valid Socket")
test_error(.context(fakesock), "valid Socket")
test_error(stat(fakesock, "pipes"), "valid Socket")
test_error(close(fakesock), "valid Socket")
test_true(!.unresolved(fakesock))
fakectx <- `class<-`("test", "nanoContext")
test_true(!unresolved(fakectx))
test_true(!.unresolved(fakectx))
test_error(request(fakectx, data = "test"), "valid Context")
test_error(subscribe(fakectx, NULL), "valid")
test_error(close(fakectx), "valid Context")
test_true(reap(fakectx) == 3L)
fakestream <- `class<-`("test", "nanoStream")
test_print(fakestream)
fakesession <- `class<-`("test", "ncurlSession")
test_print(fakesession)
test_error(transact(fakesession), "valid")
test_error(close(fakesession), "valid")
test_error(send(fakestream, "test"), "valid")
test_error(send_aio(fakestream, "test"), "valid")
test_error(recv(fakestream), "valid")
test_error(recv_aio(fakestream), "valid")
test_error(collect_pipe(fakestream), "valid")
test_error(opt(fakestream, name = "test") <- "test", "valid")
test_error(opt(fakestream, name = "test"), "valid")
test_error(close(fakestream), "active Stream")
fakedial <- `class<-`("test", "nanoDialer")
test_error(start(fakedial), "valid Dialer")
test_error(close(fakedial), "valid Dialer")
fakelist <- `class<-`("test", "nanoListener")
test_error(start(fakelist), "valid Listener")
test_error(close(fakelist), "valid Listener")
fakepipe <- `class<-`("test", "nanoPipe")
test_error(close(fakepipe), "valid Pipe")
unres <- `class<-`(NA, "unresolvedValue")
test_true(!unresolved(unres))
test_print(unres)
test_true(is.logical(unres <- unresolved(list("a", "b"))))
test_equal(length(unres), 1L)
test_true(is.integer(unres <- .unresolved(list("a", "b"))))
test_equal(length(unres), 1L)
test_identical(call_aio("a"), "a")
test_identical(call_aio_("a"), "a")
test_error(collect_aio_("a"), "object is not an Aio or list of Aios")
test_error(collect_aio_(list("a")), "object is not an Aio or list of Aios")
test_error(collect_aio(list(fakesock)), "object is not an Aio or list of Aios")
test_null(stop_aio("a"))
test_null(stop_aio(list("a")))
test_null(.keep(NULL, new.env()))
test_null(.keep(new.env(), new.env()))

pem <- "-----BEGIN CERTIFICATE----- -----END CERTIFICATE-----"
test_tls <- function(pem) {
  file <- tempfile()
  on.exit(unlink(file))
  cat(pem, file = file)
  test_error(tls_config(client = file), "Cryptographic error")
  test_error(tls_config(server = file), "Cryptographic error")
}
test_true(test_tls(pem = pem))
test_error(tls_config(client = c(pem, pem)), "Cryptographic error")
test_error(tls_config(server = c(pem, pem)), "Cryptographic error")
test_true(is.list(cert <- write_cert(cn = "127.0.0.1")))
test_equal(length(cert), 2L)
test_true(is.character(cert[[1L]]))
test_identical(names(cert), c("server", "client"))
test_xptr(tls <- tls_config(client = cert$client))
test_true(inherits(tls, "tlsConfig"))
test_print(tls)
test_errorvalue(ncurl("https://www.example.com/", tls = tls)$status)
test_errorvalue(call_aio(ncurl_aio("https://www.example.com/", tls = tls))$data)
test_error(ncurl_session("https://www.example.com/", tls = cert$client), "not a valid TLS")
sess <- ncurl_session("https://www.example.com/", tls = tls)
test_true(is_ncurl_session(sess) || is_error_value(sess))
if (is_ncurl_session(sess)) test_errorvalue(transact(sess)[["headers"]])
test_xptr(s <- socket(listen = "tls+tcp://127.0.0.1:5556", tls = tls_config(server = cert$server)))
test_xptr(s1 <- socket(dial = "tls+tcp://127.0.0.1:5556", tls = tls))
test_truew(dial(s, url = "tls+tcp://.", tls = tls, error = FALSE) > 0)
test_truew(listen(s, url = "tls+tcp://.", tls = tls, error = FALSE) > 0)
test_zero(close(s1))
test_zero(close(s))
if (promises) test_nano(s <- socket(listen = "inproc://nanonext"))
if (promises) test_nano(s1 <- socket(dial = "inproc://nanonext"))
if (promises) test_aio(r <- recv_aio(s, timeout = 500L))
if (promises) test_true(promises::is.promise(promises::then(r, identity, identity)))
if (promises) test_true(is.integer(send(s1, "promises test\n", block = 500L)))
if (promises) test_aio(r2 <- recv_aio(s, timeout = 1L))
if (promises) test_true(promises::is.promising(call_aio(r2)))
if (promises) test_true(promises::is.promise(promises::then(r2, identity, identity)))
if (promises) test_true(promises::is.promising(call_aio(r)))
if (promises) test_aio(n <- ncurl_aio("https://postman-echo.com/get"))
if (promises) test_true(promises::is.promise(promises::then(n, identity, identity)))
if (promises) test_true(promises::is.promising(call_aio(n)))
if (promises) test_true(promises::is.promise(promises::as.promise(call_aio(ncurl_aio("https://postman-echo.com/get")))))
if (promises) later::run_now()
if (promises) test_zero(close(s1))
if (promises) test_zero(close(s))
if (promises) later::run_now()
test_true(!identical(get0(".Random.seed"), {.advance(); .Random.seed}))
if (Sys.info()[["sysname"]] == "Linux") {
  rm(list = ls())
  gc()
  Sys.sleep(1L)
  .Call(nanonext:::rnng_fini)
  invisible()
}
