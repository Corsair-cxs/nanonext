# nanonext - Utilities ---------------------------------------------------------

#' NNG Library Version
#'
#' Returns the version of 'libnng' used and whether TLS is supported.
#'
#' @return A character vector of length 2.
#'
#' @section TLS Support:
#'
#'     The environment variable 'NANONEXT_TLS' may be set, e.g. by
#'     \code{Sys.setenv(NANONEXT_TLS=1)}, prior to package installation to enable
#'     TLS where the system NNG library has been built with TLS support (using
#'     Mbed TLS). Note: this is not applicable to Windows systems.
#'
#' @examples
#' nng_version()
#'
#' @export
#'
nng_version <- function() .Call(rnng_version)

#' Translate Error Codes
#'
#' Translate integer exit code to human readable form. All package functions
#'     return an integer exit code on error rather than the expected return
#'     value.
#'
#' @param xc integer exit code to translate.
#'
#' @return A character vector.
#'
#' @examples
#' nng_error(1L)
#'
#' @export
#'
nng_error <- function(xc) .Call(rnng_strerror, as.integer(xc))

#' Is Nul Byte
#'
#' Is the object a nul byte.
#'
#' @param x an object.
#'
#' @return Logical value TRUE or FALSE.
#'
#' @examples
#' is_nul_byte(as.raw(0L))
#' is_nul_byte(raw(length = 1L))
#' is_nul_byte(writeBin("", con = raw()))
#'
#' is_nul_byte(0L)
#' is_nul_byte(NULL)
#' is_nul_byte(NA)
#'
#' @export
#'
is_nul_byte <- function(x) identical(x, as.raw(0L))

#' Is Error Value
#'
#' Is the object an error value generated by NNG. All receive functions class
#'     integer error codes as 'errorValue' to be easily distinguishable from
#'     integer message values.
#'
#' @param x an object.
#'
#' @return Logical value TRUE if 'x' is of class 'errorValue', FALSE otherwise.
#'
#' @examples
#' is_error_value(1L)
#'
#' @export
#'
is_error_value <- function(x) inherits(x, "errorValue")

#' Logging Level
#'
#' Set the logging level of nanonext.
#'
#' @param level specify a logging level
#'     \itemize{
#'     \item{'keep'} {which keeps the current logging level}
#'     \item{'check'} {which checks the value of environment variable 'NANONEXT_LOG'}
#'     \item{'error'} {which sends all NNG errors to stderr}
#'     \item{'info'} {which in addition sends key informational events such as
#'     socket open etc. to stdout}
#'     }
#'
#' @return Invisible NULL. A confirmation is printed to the console (stdout) if
#'     the logging level has changed. If the function is called with no arguments,
#'     the integer code of the logging level is returned instead.
#'
#' @details The environment variable 'NANONEXT_LOG' is checked automatically on
#'     package load and then cached for optimal performance. It is also checked
#'     each time \code{logging(level = "check")} is called. If the variable is
#'     set incorrectly, the default level of 'error' is used instead.
#'
#' @examples
#' logging(level = "info")
#' sock <- socket("respondent", dial = "inproc://nanolog")
#' logging(level = "error")
#' close(sock)
#'
#' @export
#'
logging <- function(level) {

  cache <- switch(tolower(Sys.getenv("NANONEXT_LOG")),
                  info = 1L,
                  0L)

  logging <- function(level = c("keep", "check", "error", "info")) {

    missing(level) && return(cache)
    level <- match.arg(level)
    original <- cache
    cache <<- switch(level,
                     check = switch(tolower(Sys.getenv("NANONEXT_LOG")),
                                    info = 1L,
                                    0L),
                     error = 0L,
                     info = 1L,
                     keep = original)
    if (cache != original) cat(sprintf("%s [ %s ] %s: %s\n",
                                       format.POSIXct(Sys.time()), "log level", "set to",
                                       if (cache) "info" else "error"),  file = stdout())

  }

}

# nanonext - Non-exported functions --------------------------------------------

encode <- function(data, mode) {
  switch(mode,
         serial = serialize(object = data, connection = NULL),
         raw = if (is.raw(data)) data else writeBin(object = data, con = raw()))
}

decode <- function(con, mode) {
  switch(mode,
         serial = unserialize(connection = con),
         character = (r <- readBin(con = con, what = mode, n = length(con)))[r != ""],
         raw = con,
         readBin(con = con, what = mode, n = length(con)))
}

logerror <- function(xc) {
  message(sprintf("%s [ %d ] %s",
                  format.POSIXct(Sys.time()), xc, .Call(rnng_strerror, xc)))
}

loginfo <- function(evt, pkey, pval, skey, sval) {
  cat(sprintf("%s [ %s ] %s: %d | %s: %s\n",
              format.POSIXct(Sys.time()), evt, pkey, pval, skey, sval), file = stdout())
}

